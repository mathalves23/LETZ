{"ast":null,"code":"import{createSlice,createAsyncThunk}from'@reduxjs/toolkit';import{eventAPI}from'../../services/api';const initialState={events:[],myEvents:[],participatingEvents:[],upcomingEvents:[],currentEvent:null,isLoading:false,error:null};// Async thunks\nexport const createEvent=createAsyncThunk('events/create',async(eventData,_ref)=>{let{rejectWithValue}=_ref;try{const response=await eventAPI.createEvent(eventData);return response.data;}catch(error){var _error$response,_error$response$data;return rejectWithValue(((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.message)||'Erro ao criar evento');}});export const fetchMyEvents=createAsyncThunk('events/fetchMy',async(_,_ref2)=>{let{rejectWithValue}=_ref2;try{const response=await eventAPI.getMyEvents();return response.data;}catch(error){var _error$response2,_error$response2$data;return rejectWithValue(((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.message)||'Erro ao buscar eventos');}});export const fetchParticipatingEvents=createAsyncThunk('events/fetchParticipating',async(_,_ref3)=>{let{rejectWithValue}=_ref3;try{const response=await eventAPI.getMyEvents();// Ajustar quando tiver endpoint específico\nreturn response.data;}catch(error){var _error$response3,_error$response3$data;return rejectWithValue(((_error$response3=error.response)===null||_error$response3===void 0?void 0:(_error$response3$data=_error$response3.data)===null||_error$response3$data===void 0?void 0:_error$response3$data.message)||'Erro ao buscar eventos');}});export const fetchUpcomingEvents=createAsyncThunk('events/fetchUpcoming',async(_,_ref4)=>{let{rejectWithValue}=_ref4;try{const response=await eventAPI.getUpcomingEvents();return response.data;}catch(error){var _error$response4,_error$response4$data;return rejectWithValue(((_error$response4=error.response)===null||_error$response4===void 0?void 0:(_error$response4$data=_error$response4.data)===null||_error$response4$data===void 0?void 0:_error$response4$data.message)||'Erro ao buscar eventos');}});export const fetchEventById=createAsyncThunk('events/fetchById',async(eventId,_ref5)=>{let{rejectWithValue}=_ref5;try{const response=await eventAPI.getEventById(eventId);return response.data;}catch(error){var _error$response5,_error$response5$data;return rejectWithValue(((_error$response5=error.response)===null||_error$response5===void 0?void 0:(_error$response5$data=_error$response5.data)===null||_error$response5$data===void 0?void 0:_error$response5$data.message)||'Erro ao buscar evento');}});export const fetchEventByInviteCode=createAsyncThunk('events/fetchByInviteCode',async(inviteCode,_ref6)=>{let{rejectWithValue}=_ref6;try{const response=await eventAPI.getEventByInviteCode(inviteCode);return response.data;}catch(error){var _error$response6,_error$response6$data;return rejectWithValue(((_error$response6=error.response)===null||_error$response6===void 0?void 0:(_error$response6$data=_error$response6.data)===null||_error$response6$data===void 0?void 0:_error$response6$data.message)||'Convite inválido');}});export const joinEvent=createAsyncThunk('events/join',async(eventId,_ref7)=>{let{rejectWithValue}=_ref7;try{const response=await eventAPI.joinEvent(eventId);return response.data;}catch(error){var _error$response7,_error$response7$data;return rejectWithValue(((_error$response7=error.response)===null||_error$response7===void 0?void 0:(_error$response7$data=_error$response7.data)===null||_error$response7$data===void 0?void 0:_error$response7$data.message)||'Erro ao participar do evento');}});export const leaveEvent=createAsyncThunk('events/leave',async(eventId,_ref8)=>{let{rejectWithValue}=_ref8;try{await eventAPI.leaveEvent(eventId);return eventId;}catch(error){var _error$response8,_error$response8$data;return rejectWithValue(((_error$response8=error.response)===null||_error$response8===void 0?void 0:(_error$response8$data=_error$response8.data)===null||_error$response8$data===void 0?void 0:_error$response8$data.message)||'Erro ao sair do evento');}});export const updateEvent=createAsyncThunk('events/update',async(_ref9,_ref0)=>{let{eventId,eventData}=_ref9;let{rejectWithValue}=_ref0;try{const response=await eventAPI.updateEvent(eventId,eventData);return response.data;}catch(error){var _error$response9,_error$response9$data;return rejectWithValue(((_error$response9=error.response)===null||_error$response9===void 0?void 0:(_error$response9$data=_error$response9.data)===null||_error$response9$data===void 0?void 0:_error$response9$data.message)||'Erro ao atualizar evento');}});export const deleteEvent=createAsyncThunk('events/delete',async(eventId,_ref1)=>{let{rejectWithValue}=_ref1;try{await eventAPI.deleteEvent(eventId);return eventId;}catch(error){var _error$response0,_error$response0$data;return rejectWithValue(((_error$response0=error.response)===null||_error$response0===void 0?void 0:(_error$response0$data=_error$response0.data)===null||_error$response0$data===void 0?void 0:_error$response0$data.message)||'Erro ao deletar evento');}});const eventSlice=createSlice({name:'events',initialState,reducers:{clearError:state=>{state.error=null;},clearCurrentEvent:state=>{state.currentEvent=null;},setCurrentEvent:(state,action)=>{state.currentEvent=action.payload;}},extraReducers:builder=>{builder// Create Event\n.addCase(createEvent.pending,state=>{state.isLoading=true;state.error=null;}).addCase(createEvent.fulfilled,(state,action)=>{state.isLoading=false;state.myEvents.unshift(action.payload);state.error=null;}).addCase(createEvent.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Fetch My Events\n.addCase(fetchMyEvents.pending,state=>{state.isLoading=true;state.error=null;}).addCase(fetchMyEvents.fulfilled,(state,action)=>{state.isLoading=false;state.myEvents=action.payload;state.error=null;}).addCase(fetchMyEvents.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Fetch Participating Events\n.addCase(fetchParticipatingEvents.pending,state=>{state.isLoading=true;state.error=null;}).addCase(fetchParticipatingEvents.fulfilled,(state,action)=>{state.isLoading=false;state.participatingEvents=action.payload;state.error=null;}).addCase(fetchParticipatingEvents.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Fetch Upcoming Events\n.addCase(fetchUpcomingEvents.pending,state=>{state.isLoading=true;state.error=null;}).addCase(fetchUpcomingEvents.fulfilled,(state,action)=>{state.isLoading=false;state.upcomingEvents=action.payload;state.error=null;}).addCase(fetchUpcomingEvents.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Fetch Event By ID\n.addCase(fetchEventById.pending,state=>{state.isLoading=true;state.error=null;}).addCase(fetchEventById.fulfilled,(state,action)=>{state.isLoading=false;state.currentEvent=action.payload;state.error=null;}).addCase(fetchEventById.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Fetch Event By Invite Code\n.addCase(fetchEventByInviteCode.pending,state=>{state.isLoading=true;state.error=null;}).addCase(fetchEventByInviteCode.fulfilled,(state,action)=>{state.isLoading=false;state.currentEvent=action.payload;state.error=null;}).addCase(fetchEventByInviteCode.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Join Event\n.addCase(joinEvent.pending,state=>{state.isLoading=true;state.error=null;}).addCase(joinEvent.fulfilled,(state,action)=>{state.isLoading=false;state.currentEvent=action.payload;// Adicionar aos eventos participando se não estiver lá\nif(!state.participatingEvents.find(e=>e.id===action.payload.id)){state.participatingEvents.push(action.payload);}state.error=null;}).addCase(joinEvent.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Leave Event\n.addCase(leaveEvent.pending,state=>{state.isLoading=true;state.error=null;}).addCase(leaveEvent.fulfilled,(state,action)=>{state.isLoading=false;// Remover dos eventos participando\nstate.participatingEvents=state.participatingEvents.filter(e=>e.id!==action.payload);state.error=null;}).addCase(leaveEvent.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Update Event\n.addCase(updateEvent.pending,state=>{state.isLoading=true;state.error=null;}).addCase(updateEvent.fulfilled,(state,action)=>{var _state$currentEvent;state.isLoading=false;const updatedEvent=action.payload;// Atualizar nos meus eventos\nconst myEventIndex=state.myEvents.findIndex(e=>e.id===updatedEvent.id);if(myEventIndex!==-1){state.myEvents[myEventIndex]=updatedEvent;}// Atualizar evento atual\nif(((_state$currentEvent=state.currentEvent)===null||_state$currentEvent===void 0?void 0:_state$currentEvent.id)===updatedEvent.id){state.currentEvent=updatedEvent;}state.error=null;}).addCase(updateEvent.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;})// Delete Event\n.addCase(deleteEvent.pending,state=>{state.isLoading=true;state.error=null;}).addCase(deleteEvent.fulfilled,(state,action)=>{var _state$currentEvent2;state.isLoading=false;const eventId=action.payload;// Remover dos meus eventos\nstate.myEvents=state.myEvents.filter(e=>e.id!==eventId);// Limpar evento atual se for o mesmo\nif(((_state$currentEvent2=state.currentEvent)===null||_state$currentEvent2===void 0?void 0:_state$currentEvent2.id)===eventId){state.currentEvent=null;}state.error=null;}).addCase(deleteEvent.rejected,(state,action)=>{state.isLoading=false;state.error=action.payload;});}});export const{clearError,clearCurrentEvent,setCurrentEvent}=eventSlice.actions;export default eventSlice.reducer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}