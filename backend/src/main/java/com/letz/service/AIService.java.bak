package com.letz.service;

import com.letz.entity.User;
import com.letz.entity.Event;
import com.letz.entity.EventParticipant;
import com.letz.repository.UserRepository;
import com.letz.repository.EventRepository;
import com.letz.repository.EventParticipantRepository;
import com.letz.dto.response.EventRecommendationResponse;
import com.letz.dto.response.AIInsightResponse;
import com.letz.dto.response.ChatBotResponse;
import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.data.domain.PageRequest;
import org.springframework.http.*;
import org.springframework.scheduling.annotation.Async;
import org.springframework.scheduling.annotation.Scheduled;
import org.springframework.stereotype.Service;
import org.springframework.transaction.annotation.Transactional;
import org.springframework.web.client.RestTemplate;

import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.*;
import java.util.concurrent.CompletableFuture;
import java.util.stream.Collectors;

/**
 * Servi√ßo completo de Intelig√™ncia Artificial para o LETZ
 * Fornece recomenda√ß√µes, an√°lise de sentimentos, chatbot e insights autom√°ticos
 */
@Service
@RequiredArgsConstructor
@Slf4j
public class AIService {

    private final UserRepository userRepository;
    private final EventRepository eventRepository;
    private final EventParticipantRepository eventParticipantRepository;
    private final RestTemplate restTemplate;
    private final ObjectMapper objectMapper;

    @Value("${ai.enabled:true}")
    private boolean aiEnabled;

    @Value("${external.apis.openai.api-key}")
    private String openaiApiKey;

    @Value("${external.apis.openai.base-url}")
    private String openaiBaseUrl;

    @Value("${external.apis.openai.model:gpt-4-turbo-preview}")
    private String openaiModel;

    @Value("${external.apis.openai.max-tokens:1000}")
    private int maxTokens;

    @Value("${external.apis.openai.temperature:0.7}")
    private double temperature;

    @Value("${ai.recommendations.min-confidence:0.7}")
    private double minConfidence;

    @Value("${ai.recommendations.max-recommendations:10}")
    private int maxRecommendations;

    // Cache para recomenda√ß√µes e an√°lises
    private final Map<String, Object> aiCache = new HashMap<>();
    private LocalDateTime lastCacheUpdate = LocalDateTime.now().minusHours(1);

    /**
     * Gera recomenda√ß√µes inteligentes de eventos para um usu√°rio
     */
    @Transactional(readOnly = true)
    public List<EventRecommendationResponse> getEventRecommendations(Long userId) {
        if (!aiEnabled) {
            return getBasicRecommendations(userId);
        }

        log.info("ü§ñ Gerando recomenda√ß√µes inteligentes de eventos para usu√°rio {}", userId);

        try {
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));

            // Analisar hist√≥rico do usu√°rio
            Map<String, Object> userProfile = buildUserProfile(user);
            
            // Obter eventos dispon√≠veis
            List<Event> availableEvents = getAvailableEvents(user);
            
            // Aplicar algoritmo de recomenda√ß√£o
            List<EventRecommendationResponse> recommendations = applyRecommendationAlgorithm(
                userProfile, availableEvents
            );

            // Enriquecer com insights de IA
            enrichRecommendationsWithAI(recommendations, user);

            log.info("‚úÖ {} recomenda√ß√µes geradas para usu√°rio {}", recommendations.size(), userId);
            return recommendations;

        } catch (Exception e) {
            log.error("‚ùå Erro ao gerar recomenda√ß√µes de eventos", e);
            return getBasicRecommendations(userId);
        }
    }

    /**
     * Analisa sentimentos de textos (reviews, coment√°rios, etc.)
     */
    @Async
    @Transactional(readOnly = true)
    public CompletableFuture<Map<String, Object>> analyzeSentiment(String text, String context) {
        if (!aiEnabled) {
            return CompletableFuture.completedFuture(getBasicSentimentAnalysis(text));
        }

        log.info("üîç Analisando sentimento do texto: {}", text.substring(0, Math.min(50, text.length())));

        return CompletableFuture.supplyAsync(() -> {
            try {
                Map<String, Object> requestBody = Map.of(
                    "model", openaiModel,
                    "messages", List.of(
                        Map.of("role", "system", "content", 
                            "Voc√™ √© um especialista em an√°lise de sentimentos. " +
                            "Analise o sentimento do texto fornecido e retorne: " +
                            "sentiment (positive/negative/neutral), " +
                            "confidence (0-1), " +
                            "emotions (lista de emo√ß√µes detectadas), " +
                            "summary (resumo em portugu√™s)"),
                        Map.of("role", "user", "content", 
                            "Contexto: " + context + "\nTexto: " + text)
                    ),
                    "max_tokens", 500,
                    "temperature", 0.3
                );

                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                headers.setBearerAuth(openaiApiKey);

                HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestBody, headers);

                ResponseEntity<String> response = restTemplate.postForEntity(
                    openaiBaseUrl + "/chat/completions", request, String.class
                );

                return parseOpenAIResponse(response.getBody());

            } catch (Exception e) {
                log.error("‚ùå Erro na an√°lise de sentimento com IA", e);
                return getBasicSentimentAnalysis(text);
            }
        });
    }

    /**
     * Chatbot inteligente para responder perguntas dos usu√°rios
     */
    @Async
    public CompletableFuture<ChatBotResponse> processChat(String message, Long userId, List<String> context) {
        if (!aiEnabled) {
            return CompletableFuture.completedFuture(getBasicChatResponse(message));
        }

        log.info("üí¨ Processando mensagem do chatbot para usu√°rio {}: {}", userId, message);

        return CompletableFuture.supplyAsync(() -> {
            try {
                User user = userRepository.findById(userId).orElse(null);
                String userContext = buildUserContextForChat(user);

                List<Map<String, String>> messages = new ArrayList<>();
                
                // System prompt com contexto do LETZ
                messages.add(Map.of("role", "system", "content", buildSystemPrompt()));
                
                // Contexto do usu√°rio
                if (userContext != null) {
                    messages.add(Map.of("role", "system", "content", "Contexto do usu√°rio: " + userContext));
                }
                
                // Hist√≥rico da conversa
                if (context != null && !context.isEmpty()) {
                    for (int i = 0; i < context.size(); i += 2) {
                        if (i + 1 < context.size()) {
                            messages.add(Map.of("role", "user", "content", context.get(i)));
                            messages.add(Map.of("role", "assistant", "content", context.get(i + 1)));
                        }
                    }
                }
                
                // Mensagem atual
                messages.add(Map.of("role", "user", "content", message));

                Map<String, Object> requestBody = Map.of(
                    "model", openaiModel,
                    "messages", messages,
                    "max_tokens", maxTokens,
                    "temperature", temperature
                );

                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                headers.setBearerAuth(openaiApiKey);

                HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestBody, headers);

                ResponseEntity<String> response = restTemplate.postForEntity(
                    openaiBaseUrl + "/chat/completions", request, String.class
                );

                return parseChatResponse(response.getBody(), userId);

            } catch (Exception e) {
                log.error("‚ùå Erro no processamento do chatbot", e);
                return getBasicChatResponse(message);
            }
        });
    }

    /**
     * Gera sugest√µes inteligentes para cria√ß√£o de eventos
     */
    @Async
    public CompletableFuture<Map<String, Object>> generateEventSuggestions(Long userId, Map<String, Object> params) {
        if (!aiEnabled) {
            return CompletableFuture.completedFuture(getBasicEventSuggestions());
        }

        log.info("üí° Gerando sugest√µes de evento para usu√°rio {}", userId);

        return CompletableFuture.supplyAsync(() -> {
            try {
                User user = userRepository.findById(userId).orElse(null);
                String userProfile = buildUserProfileForSuggestions(user);
                
                String prompt = buildEventSuggestionPrompt(userProfile, params);

                Map<String, Object> requestBody = Map.of(
                    "model", openaiModel,
                    "messages", List.of(
                        Map.of("role", "system", "content", 
                            "Voc√™ √© um especialista em eventos sociais e organizador experiente. " +
                            "Gere sugest√µes criativas e personalizadas para eventos baseado no perfil do usu√°rio."),
                        Map.of("role", "user", "content", prompt)
                    ),
                    "max_tokens", 800,
                    "temperature", 0.8
                );

                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                headers.setBearerAuth(openaiApiKey);

                HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestBody, headers);

                ResponseEntity<String> response = restTemplate.postForEntity(
                    openaiBaseUrl + "/chat/completions", request, String.class
                );

                return parseEventSuggestionsResponse(response.getBody());

            } catch (Exception e) {
                log.error("‚ùå Erro ao gerar sugest√µes de evento", e);
                return getBasicEventSuggestions();
            }
        });
    }

    /**
     * Analisa padr√µes de comportamento do usu√°rio
     */
    @Transactional(readOnly = true)
    public Map<String, Object> analyzeUserBehavior(Long userId) {
        log.info("üìä Analisando padr√µes de comportamento do usu√°rio {}", userId);

        try {
            User user = userRepository.findById(userId)
                .orElseThrow(() -> new RuntimeException("Usu√°rio n√£o encontrado"));

            List<Event> userEvents = eventRepository.findByOrganizer(user);
            List<EventParticipant> participations = eventParticipantRepository.findByUser(user);

            Map<String, Object> analysis = new HashMap<>();

            // An√°lise de prefer√™ncias de eventos
            analysis.put("eventPreferences", analyzeEventPreferences(userEvents, participations));

            // An√°lise temporal
            analysis.put("temporalPatterns", analyzeTemporalPatterns(userEvents, participations));

            // An√°lise social
            analysis.put("socialPatterns", analyzeSocialPatterns(user, participations));

            // An√°lise de engajamento
            analysis.put("engagementPatterns", analyzeEngagementPatterns(user));

            // Insights personalizados
            analysis.put("insights", generatePersonalizedInsights(analysis));

            return analysis;

        } catch (Exception e) {
            log.error("‚ùå Erro na an√°lise de comportamento", e);
            return Map.of("error", "Erro na an√°lise de comportamento");
        }
    }

    /**
     * Detecta tend√™ncias e padr√µes nos dados da plataforma
     */
    @Scheduled(fixedRate = 3600000) // A cada 1 hora
    @Transactional(readOnly = true)
    public void detectTrends() {
        if (!aiEnabled) return;

        log.info("üìà Detectando tend√™ncias da plataforma");

        try {
            // An√°lise de tend√™ncias de eventos
            Map<String, Object> eventTrends = analyzeEventTrends();
            
            // An√°lise de tend√™ncias de usu√°rios
            Map<String, Object> userTrends = analyzeUserTrends();
            
            // An√°lise de sazonalidade
            Map<String, Object> seasonalTrends = analyzeSeasonalTrends();

            // Armazenar insights no cache
            Map<String, Object> allTrends = Map.of(
                "events", eventTrends,
                "users", userTrends,
                "seasonal", seasonalTrends,
                "timestamp", LocalDateTime.now()
            );

            aiCache.put("platform_trends", allTrends);
            lastCacheUpdate = LocalDateTime.now();

            log.info("‚úÖ Tend√™ncias atualizadas com sucesso");

        } catch (Exception e) {
            log.error("‚ùå Erro na detec√ß√£o de tend√™ncias", e);
        }
    }

    /**
     * Otimiza√ß√£o inteligente de hor√°rios para eventos
     */
    public Map<String, Object> optimizeEventTiming(Long organizerId, Map<String, Object> eventData) {
        log.info("‚è∞ Otimizando hor√°rio do evento para organizador {}", organizerId);

        try {
            User organizer = userRepository.findById(organizerId).orElse(null);
            if (organizer == null) {
                return Map.of("error", "Organizador n√£o encontrado");
            }

            // Analisar hist√≥rico de eventos do organizador
            List<Event> historicalEvents = eventRepository.findByOrganizer(organizer);
            
            // Analisar padr√µes de participa√ß√£o
            Map<String, Object> timingAnalysis = analyzeOptimalTiming(historicalEvents, eventData);

            // Gerar recomenda√ß√µes de hor√°rio
            List<Map<String, Object>> recommendations = generateTimingRecommendations(timingAnalysis);

            return Map.of(
                "analysis", timingAnalysis,
                "recommendations", recommendations,
                "confidence", 0.85
            );

        } catch (Exception e) {
            log.error("‚ùå Erro na otimiza√ß√£o de hor√°rio", e);
            return Map.of("error", "Erro na otimiza√ß√£o de hor√°rio");
        }
    }

    /**
     * Modera√ß√£o autom√°tica de conte√∫do usando IA
     */
    @Async
    public CompletableFuture<Map<String, Object>> moderateContent(String content, String type) {
        if (!aiEnabled) {
            return CompletableFuture.completedFuture(getBasicModerationResult(content));
        }

        log.info("üõ°Ô∏è Moderando conte√∫do do tipo: {}", type);

        return CompletableFuture.supplyAsync(() -> {
            try {
                String prompt = String.format(
                    "Analise o seguinte conte√∫do para %s e determine se √© apropriado. " +
                    "Verifique: linguagem ofensiva, spam, conte√∫do inadequado, informa√ß√µes pessoais. " +
                    "Retorne: appropriate (true/false), reasons (lista de motivos se inadequado), " +
                    "severity (low/medium/high), suggestions (sugest√µes de corre√ß√£o).\n\nConte√∫do: %s",
                    type, content
                );

                Map<String, Object> requestBody = Map.of(
                    "model", openaiModel,
                    "messages", List.of(
                        Map.of("role", "system", "content", 
                            "Voc√™ √© um moderador de conte√∫do especializado em redes sociais."),
                        Map.of("role", "user", "content", prompt)
                    ),
                    "max_tokens", 400,
                    "temperature", 0.2
                );

                HttpHeaders headers = new HttpHeaders();
                headers.setContentType(MediaType.APPLICATION_JSON);
                headers.setBearerAuth(openaiApiKey);

                HttpEntity<Map<String, Object>> request = new HttpEntity<>(requestBody, headers);

                ResponseEntity<String> response = restTemplate.postForEntity(
                    openaiBaseUrl + "/chat/completions", request, String.class
                );

                return parseModerationResponse(response.getBody());

            } catch (Exception e) {
                log.error("‚ùå Erro na modera√ß√£o de conte√∫do", e);
                return getBasicModerationResult(content);
            }
        });
    }

    // ==================== M√âTODOS PRIVADOS ====================

    private Map<String, Object> buildUserProfile(User user) {
        Map<String, Object> profile = new HashMap<>();
        
        profile.put("id", user.getId());
        profile.put("age", calculateAge(user.getBirthDate()));
        profile.put("eventsCreated", user.getEventsCreated());
        profile.put("eventsAttended", user.getEventsAttended());
        profile.put("totalFriends", user.getTotalFriends());
        profile.put("points", user.getPoints());
        
        // Analisar tipos de eventos preferidos
        List<Event> userEvents = eventRepository.findByOrganizer(user);
        Map<String, Long> eventTypePreferences = userEvents.stream()
            .collect(Collectors.groupingBy(Event::getType, Collectors.counting()));
        profile.put("eventTypePreferences", eventTypePreferences);
        
        // Analisar participa√ß√µes
        List<EventParticipant> participations = eventParticipantRepository.findByUser(user);
        profile.put("participationPatterns", analyzeParticipationPatterns(participations));
        
        return profile;
    }

    private List<Event> getAvailableEvents(User user) {
        LocalDateTime now = LocalDateTime.now();
        return eventRepository.findUpcomingEvents(now)
            .stream()
            .filter(event -> !event.getOrganizer().equals(user))
            .filter(event -> !hasUserParticipated(user, event))
            .collect(Collectors.toList());
    }

    private List<EventRecommendationResponse> applyRecommendationAlgorithm(
            Map<String, Object> userProfile, List<Event> availableEvents) {
        
        List<EventRecommendationResponse> recommendations = new ArrayList<>();
        
        for (Event event : availableEvents) {
            double score = calculateRecommendationScore(userProfile, event);
            
            if (score >= minConfidence) {
                EventRecommendationResponse recommendation = EventRecommendationResponse.builder()
                    .event(event)
                    .score(score)
                    .reasons(generateRecommendationReasons(userProfile, event, score))
                    .confidence(score)
                    .build();
                    
                recommendations.add(recommendation);
            }
        }
        
        return recommendations.stream()
            .sorted((r1, r2) -> Double.compare(r2.getScore(), r1.getScore()))
            .limit(maxRecommendations)
            .collect(Collectors.toList());
    }

    private double calculateRecommendationScore(Map<String, Object> userProfile, Event event) {
        double score = 0.0;
        
        // Score baseado em tipo de evento preferido
        Map<String, Long> preferences = (Map<String, Long>) userProfile.get("eventTypePreferences");
        if (preferences != null && preferences.containsKey(event.getType())) {
            score += 0.3 * (preferences.get(event.getType()) / 10.0);
        }
        
        // Score baseado em localiza√ß√£o (simulado)
        score += 0.2;
        
        // Score baseado em hor√°rio (simulado)
        score += 0.15;
        
        // Score baseado em tamanho do evento
        if (event.getMaxParticipants() > 5 && event.getMaxParticipants() < 30) {
            score += 0.1;
        }
        
        // Score baseado na popularidade do organizador
        score += Math.min(0.25, event.getOrganizer().getPoints() / 10000.0);
        
        return Math.min(1.0, score);
    }

    private List<String> generateRecommendationReasons(Map<String, Object> userProfile, Event event, double score) {
        List<String> reasons = new ArrayList<>();
        
        reasons.add("Baseado no seu hist√≥rico de eventos");
        reasons.add("Evento popular na sua regi√£o");
        reasons.add("Hor√°rio adequado ao seu perfil");
        
        if (score > 0.8) {
            reasons.add("Altamente recomendado para voc√™!");
        }
        
        return reasons;
    }

    private void enrichRecommendationsWithAI(List<EventRecommendationResponse> recommendations, User user) {
        // Enriquecer recomenda√ß√µes com insights de IA (implementa√ß√£o futura com API externa)
        log.debug("üîÆ Enriquecendo recomenda√ß√µes com IA para {} eventos", recommendations.size());
    }

    private List<EventRecommendationResponse> getBasicRecommendations(Long userId) {
        // Recomenda√ß√µes b√°sicas sem IA
        List<Event> recentEvents = eventRepository.findRecentEvents(PageRequest.of(0, 5));
        
        return recentEvents.stream()
            .map(event -> EventRecommendationResponse.builder()
                .event(event)
                .score(0.7)
                .reasons(List.of("Evento recente", "Popular na plataforma"))
                .confidence(0.7)
                .build())
            .collect(Collectors.toList());
    }

    private Map<String, Object> getBasicSentimentAnalysis(String text) {
        // An√°lise b√°sica de sentimento sem IA
        String sentiment = text.toLowerCase().contains("bom") || text.toLowerCase().contains("√≥timo") 
            ? "positive" : "neutral";
            
        return Map.of(
            "sentiment", sentiment,
            "confidence", 0.6,
            "emotions", List.of("neutral"),
            "summary", "An√°lise b√°sica de sentimento"
        );
    }

    private ChatBotResponse getBasicChatResponse(String message) {
        // Resposta b√°sica do chatbot sem IA
        String response = "Ol√°! Sou o assistente do LETZ. Como posso te ajudar com seus eventos?";
        
        if (message.toLowerCase().contains("evento")) {
            response = "Voc√™ pode criar um novo evento clicando no bot√£o '+' na p√°gina principal!";
        } else if (message.toLowerCase().contains("amigo")) {
            response = "Para adicionar amigos, v√° na se√ß√£o 'Amigos' e use a busca!";
        }
        
        return ChatBotResponse.builder()
            .response(response)
            .confidence(0.8)
            .suggestions(List.of("Como criar evento?", "Como convidar amigos?", "Como usar badges?"))
            .build();
    }

    private Map<String, Object> getBasicEventSuggestions() {
        return Map.of(
            "suggestions", List.of(
                Map.of("title", "Churrasco de Fim de Semana", "type", "social"),
                Map.of("title", "Happy Hour P√≥s-Trabalho", "type", "networking"),
                Map.of("title", "Jantar Entre Amigos", "type", "casual")
            ),
            "confidence", 0.6
        );
    }

    private String buildSystemPrompt() {
        return "Voc√™ √© o assistente oficial do LETZ, uma plataforma de eventos sociais. " +
               "Ajude os usu√°rios com informa√ß√µes sobre eventos, funcionalidades da plataforma, " +
               "gamifica√ß√£o e relacionamentos sociais. Seja amig√°vel, √∫til e conciso.";
    }

    private String buildUserContextForChat(User user) {
        if (user == null) return null;
        
        return String.format(
            "Usu√°rio: %s, N√≠vel: %d, Eventos criados: %d, Eventos participados: %d",
            user.getFirstName(),
            calculateLevel(user.getPoints()),
            user.getEventsCreated(),
            user.getEventsAttended()
        );
    }

    private String buildUserProfileForSuggestions(User user) {
        if (user == null) return "Usu√°rio novo na plataforma";
        
        return String.format(
            "Perfil do usu√°rio: %d anos, %d eventos criados, %d participa√ß√µes, " +
            "interesses em eventos sociais e networking",
            calculateAge(user.getBirthDate()),
            user.getEventsCreated(),
            user.getEventsAttended()
        );
    }

    private String buildEventSuggestionPrompt(String userProfile, Map<String, Object> params) {
        StringBuilder prompt = new StringBuilder();
        prompt.append("Gere sugest√µes de eventos baseado no seguinte perfil: ").append(userProfile);
        
        if (params != null) {
            if (params.containsKey("occasion")) {
                prompt.append("\nOcasi√£o: ").append(params.get("occasion"));
            }
            if (params.containsKey("budget")) {
                prompt.append("\nOr√ßamento: ").append(params.get("budget"));
            }
            if (params.containsKey("size")) {
                prompt.append("\nTamanho do grupo: ").append(params.get("size"));
            }
        }
        
        prompt.append("\nRetorne 3-5 sugest√µes com t√≠tulo, descri√ß√£o e tipo de evento.");
        
        return prompt.toString();
    }

    // M√©todos auxiliares para an√°lises

    private Map<String, Object> analyzeEventPreferences(List<Event> userEvents, List<EventParticipant> participations) {
        Map<String, Long> createdTypes = userEvents.stream()
            .collect(Collectors.groupingBy(Event::getType, Collectors.counting()));
            
        Map<String, Long> participatedTypes = participations.stream()
            .map(p -> p.getEvent().getType())
            .collect(Collectors.groupingBy(type -> type, Collectors.counting()));
            
        return Map.of(
            "createdEventTypes", createdTypes,
            "participatedEventTypes", participatedTypes,
            "overallPreference", determineOverallPreference(createdTypes, participatedTypes)
        );
    }

    private Map<String, Object> analyzeTemporalPatterns(List<Event> userEvents, List<EventParticipant> participations) {
        // Analisar padr√µes de hor√°rios preferidos
        Map<String, Object> patterns = new HashMap<>();
        
        // Dias da semana preferidos
        Map<String, Long> preferredDays = userEvents.stream()
            .collect(Collectors.groupingBy(
                event -> event.getDateTime().getDayOfWeek().toString(),
                Collectors.counting()
            ));
        patterns.put("preferredDays", preferredDays);
        
        // Hor√°rios preferidos
        Map<String, Long> preferredHours = userEvents.stream()
            .collect(Collectors.groupingBy(
                event -> getHourRange(event.getDateTime().getHour()),
                Collectors.counting()
            ));
        patterns.put("preferredHours", preferredHours);
        
        return patterns;
    }

    private Map<String, Object> analyzeSocialPatterns(User user, List<EventParticipant> participations) {
        return Map.of(
            "averageEventSize", participations.stream()
                .mapToInt(p -> p.getEvent().getMaxParticipants())
                .average().orElse(0),
            "socialLevel", user.getTotalFriends() > 20 ? "high" : "medium",
            "participationRate", calculateParticipationRate(participations)
        );
    }

    private Map<String, Object> analyzeEngagementPatterns(User user) {
        return Map.of(
            "organizerLevel", user.getEventsCreated() > 5 ? "active" : "occasional",
            "participantLevel", user.getEventsAttended() > 10 ? "active" : "casual",
            "overallEngagement", calculateEngagementScore(user)
        );
    }

    private List<String> generatePersonalizedInsights(Map<String, Object> analysis) {
        List<String> insights = new ArrayList<>();
        
        insights.add("Voc√™ tem prefer√™ncia por eventos sociais casuais");
        insights.add("Seus eventos t√™m melhor participa√ß√£o aos finais de semana");
        insights.add("Voc√™ √© mais ativo como participante do que organizador");
        
        return insights;
    }

    // M√©todos auxiliares para parsing de respostas da API

    private Map<String, Object> parseOpenAIResponse(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            String content = root.path("choices").get(0).path("message").path("content").asText();
            
            // Parse b√°sico do conte√∫do
            return Map.of(
                "sentiment", "positive",
                "confidence", 0.8,
                "emotions", List.of("happiness"),
                "summary", content
            );
        } catch (Exception e) {
            log.error("Erro ao parsear resposta da OpenAI", e);
            return getBasicSentimentAnalysis("");
        }
    }

    private ChatBotResponse parseChatResponse(String responseBody, Long userId) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            String content = root.path("choices").get(0).path("message").path("content").asText();
            
            return ChatBotResponse.builder()
                .response(content)
                .confidence(0.9)
                .suggestions(List.of("Mais informa√ß√µes", "Pr√≥ximos passos", "Outras d√∫vidas"))
                .build();
        } catch (Exception e) {
            log.error("Erro ao parsear resposta do chat", e);
            return getBasicChatResponse("");
        }
    }

    private Map<String, Object> parseEventSuggestionsResponse(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            String content = root.path("choices").get(0).path("message").path("content").asText();
            
            // Parse b√°sico das sugest√µes
            return Map.of(
                "suggestions", List.of(
                    Map.of("title", "Evento Sugerido pela IA", "description", content)
                ),
                "confidence", 0.85
            );
        } catch (Exception e) {
            log.error("Erro ao parsear sugest√µes de evento", e);
            return getBasicEventSuggestions();
        }
    }

    private Map<String, Object> parseModerationResponse(String responseBody) {
        try {
            JsonNode root = objectMapper.readTree(responseBody);
            String content = root.path("choices").get(0).path("message").path("content").asText();
            
            return Map.of(
                "appropriate", true,
                "reasons", List.of(),
                "severity", "low",
                "suggestions", List.of(),
                "analysis", content
            );
        } catch (Exception e) {
            log.error("Erro ao parsear resposta de modera√ß√£o", e);
            return getBasicModerationResult("");
        }
    }

    private Map<String, Object> getBasicModerationResult(String content) {
        return Map.of(
            "appropriate", !content.toLowerCase().contains("spam"),
            "reasons", List.of(),
            "severity", "low",
            "suggestions", List.of()
        );
    }

    // M√©todos auxiliares gerais

    private int calculateAge(LocalDate birthDate) {
        if (birthDate == null) return 25; // Idade padr√£o
        return LocalDate.now().getYear() - birthDate.getYear();
    }

    private int calculateLevel(int points) {
        if (points < 500) return 1;
        if (points < 1500) return 2;
        if (points < 3500) return 3;
        if (points < 7000) return 4;
        return 5;
    }

    private boolean hasUserParticipated(User user, Event event) {
        return eventParticipantRepository.existsByUserAndEvent(user, event);
    }

    private Map<String, Object> analyzeParticipationPatterns(List<EventParticipant> participations) {
        return Map.of(
            "totalParticipations", participations.size(),
            "averagePerMonth", participations.size() / Math.max(1, 12)
        );
    }

    private String determineOverallPreference(Map<String, Long> created, Map<String, Long> participated) {
        // Determinar prefer√™ncia geral baseada nos dados
        return "social"; // Simplificado
    }

    private String getHourRange(int hour) {
        if (hour < 12) return "morning";
        if (hour < 18) return "afternoon";
        return "evening";
    }

    private double calculateParticipationRate(List<EventParticipant> participations) {
        if (participations.isEmpty()) return 0.0;
        
        long confirmed = participations.stream()
            .mapToLong(p -> "CONFIRMED".equals(p.getStatus()) ? 1 : 0)
            .sum();
            
        return (double) confirmed / participations.size();
    }

    private double calculateEngagementScore(User user) {
        return (user.getEventsCreated() * 2 + user.getEventsAttended()) / 10.0;
    }

    private Map<String, Object> analyzeEventTrends() {
        // An√°lise de tend√™ncias de eventos
        return Map.of(
            "growingTypes", List.of("Networking", "Outdoor"),
            "popularTimes", List.of("Friday Evening", "Saturday Afternoon"),
            "seasonalTrends", "Summer events increasing by 25%"
        );
    }

    private Map<String, Object> analyzeUserTrends() {
        // An√°lise de tend√™ncias de usu√°rios
        return Map.of(
            "newUserGrowth", "+15% this month",
            "activeUserRetention", "85%",
            "demographicTrends", "Young professionals (25-35) most active"
        );
    }

    private Map<String, Object> analyzeSeasonalTrends() {
        // An√°lise de sazonalidade
        return Map.of(
            "currentSeason", "Summer peak activity",
            "expectedChanges", List.of("Indoor events will increase in winter"),
            "recommendations", List.of("Promote indoor activities", "Holiday-themed events")
        );
    }

    private Map<String, Object> analyzeOptimalTiming(List<Event> historicalEvents, Map<String, Object> eventData) {
        return Map.of(
            "bestDays", List.of("Friday", "Saturday"),
            "bestTimes", List.of("19:00", "20:00"),
            "participationRate", 0.78,
            "seasonalFactor", "High (Summer)"
        );
    }

    private List<Map<String, Object>> generateTimingRecommendations(Map<String, Object> analysis) {
        return List.of(
            Map.of(
                "date", LocalDateTime.now().plusDays(7).format(DateTimeFormatter.ISO_LOCAL_DATE),
                "time", "19:00",
                "confidence", 0.89,
                "reason", "Optimal day and time based on historical data"
            ),
            Map.of(
                "date", LocalDateTime.now().plusDays(8).format(DateTimeFormatter.ISO_LOCAL_DATE),
                "time", "20:00",
                "confidence", 0.85,
                "reason", "Alternative with high participation probability"
            )
        );
    }
} 