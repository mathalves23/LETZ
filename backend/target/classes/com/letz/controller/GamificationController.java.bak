package com.letz.controller;

import com.letz.service.GamificationService;
import com.letz.dto.response.GamificationStatsResponse;
import com.letz.dto.response.LeaderboardResponse;
import com.letz.entity.Badge;
import com.letz.entity.Achievement;
import io.swagger.v3.oas.annotations.Operation;
import io.swagger.v3.oas.annotations.Parameter;
import io.swagger.v3.oas.annotations.tags.Tag;
import io.swagger.v3.oas.annotations.responses.ApiResponse;
import io.swagger.v3.oas.annotations.responses.ApiResponses;
import lombok.RequiredArgsConstructor;
import lombok.extern.slf4j.Slf4j;
import org.springframework.http.ResponseEntity;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.*;

import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

/**
 * Controller para Sistema de Gamifica√ß√£o do LETZ
 * Gerencia badges, conquistas, rankings e sistema de pontos
 */
@RestController
@RequestMapping("/gamification")
@RequiredArgsConstructor
@Slf4j
@Tag(name = "Gamifica√ß√£o", description = "APIs para sistema de gamifica√ß√£o, badges e conquistas")
public class GamificationController {

    private final GamificationService gamificationService;

    /**
     * Obt√©m estat√≠sticas completas de gamifica√ß√£o do usu√°rio atual
     */
    @GetMapping("/my-stats")
    @Operation(summary = "Minhas Estat√≠sticas", 
               description = "Retorna estat√≠sticas completas de gamifica√ß√£o do usu√°rio atual")
    @ApiResponses(value = {
        @ApiResponse(responseCode = "200", description = "Estat√≠sticas retornadas com sucesso"),
        @ApiResponse(responseCode = "401", description = "Usu√°rio n√£o autenticado"),
        @ApiResponse(responseCode = "404", description = "Usu√°rio n√£o encontrado")
    })
    public ResponseEntity<GamificationStatsResponse> getMyGamificationStats(Authentication auth) {
        log.info("üéÆ Solicita√ß√£o de estat√≠sticas de gamifica√ß√£o para usu√°rio: {}", auth.getName());
        
        try {
            Long userId = getUserIdFromAuth(auth);
            GamificationStatsResponse stats = gamificationService.getUserGamificationStats(userId);
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar estat√≠sticas de gamifica√ß√£o", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Obt√©m estat√≠sticas de gamifica√ß√£o de um usu√°rio espec√≠fico
     */
    @GetMapping("/user/{userId}/stats")
    @Operation(summary = "Estat√≠sticas do Usu√°rio", 
               description = "Retorna estat√≠sticas de gamifica√ß√£o de um usu√°rio espec√≠fico")
    @PreAuthorize("hasRole('ADMIN') or hasRole('MODERATOR') or @securityService.isOwnerOrAdmin(#userId, authentication)")
    public ResponseEntity<GamificationStatsResponse> getUserGamificationStats(
            @PathVariable @Parameter(description = "ID do usu√°rio") Long userId) {
        
        log.info("üìä Solicita√ß√£o de estat√≠sticas de gamifica√ß√£o para usu√°rio: {}", userId);
        
        try {
            GamificationStatsResponse stats = gamificationService.getUserGamificationStats(userId);
            return ResponseEntity.ok(stats);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar estat√≠sticas de gamifica√ß√£o para usu√°rio {}", userId, e);
            return ResponseEntity.notFound().build();
        }
    }

    /**
     * Ranking geral de usu√°rios
     */
    @GetMapping("/leaderboard")
    @Operation(summary = "Ranking Geral", 
               description = "Retorna o ranking geral dos usu√°rios por pontos")
    public ResponseEntity<List<LeaderboardResponse>> getLeaderboard(
            @RequestParam(defaultValue = "50") @Parameter(description = "N√∫mero de usu√°rios no ranking") 
            int limit) {
        
        log.info("üèÖ Solicita√ß√£o de leaderboard - Limite: {}", limit);
        
        try {
            List<LeaderboardResponse> leaderboard = gamificationService.getLeaderboard(limit);
            return ResponseEntity.ok(leaderboard);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar leaderboard", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Ranking por categoria espec√≠fica
     */
    @GetMapping("/leaderboard/{category}")
    @Operation(summary = "Ranking por Categoria", 
               description = "Retorna ranking espec√≠fico por categoria (organizers, participants, social)")
    public ResponseEntity<List<LeaderboardResponse>> getCategoryLeaderboard(
            @PathVariable @Parameter(description = "Categoria: organizers, participants, social") 
            String category,
            
            @RequestParam(defaultValue = "25") @Parameter(description = "N√∫mero de usu√°rios no ranking") 
            int limit) {
        
        log.info("üèÜ Solicita√ß√£o de leaderboard por categoria: {} - Limite: {}", category, limit);
        
        try {
            List<LeaderboardResponse> leaderboard = gamificationService.getCategoryLeaderboard(category, limit);
            return ResponseEntity.ok(leaderboard);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar leaderboard por categoria {}", category, e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Lista todos os badges dispon√≠veis
     */
    @GetMapping("/badges")
    @Operation(summary = "Badges Dispon√≠veis", 
               description = "Lista todos os badges dispon√≠veis no sistema")
    public ResponseEntity<List<Badge>> getAllBadges() {
        log.info("üèÖ Solicita√ß√£o de lista de badges");
        
        try {
            List<Badge> badges = gamificationService.getAllBadges();
            return ResponseEntity.ok(badges);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar badges", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Lista todas as conquistas dispon√≠veis
     */
    @GetMapping("/achievements")
    @Operation(summary = "Conquistas Dispon√≠veis", 
               description = "Lista todas as conquistas dispon√≠veis no sistema")
    public ResponseEntity<List<Achievement>> getAllAchievements() {
        log.info("üèÜ Solicita√ß√£o de lista de conquistas");
        
        try {
            List<Achievement> achievements = gamificationService.getAllAchievements();
            return ResponseEntity.ok(achievements);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar conquistas", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Adiciona pontos manualmente a um usu√°rio (Admin only)
     */
    @PostMapping("/user/{userId}/points")
    @Operation(summary = "Adicionar Pontos", 
               description = "Adiciona pontos manualmente a um usu√°rio espec√≠fico")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<CompletableFuture<GamificationStatsResponse>> addPoints(
            @PathVariable @Parameter(description = "ID do usu√°rio") Long userId,
            
            @RequestParam @Parameter(description = "Quantidade de pontos a adicionar") int points,
            
            @RequestParam @Parameter(description = "Motivo da adi√ß√£o de pontos") String reason) {
        
        log.info("‚ûï Adicionando {} pontos para usu√°rio {} - Motivo: {}", points, userId, reason);
        
        try {
            CompletableFuture<GamificationStatsResponse> result = 
                gamificationService.addPoints(userId, points, reason);
            
            return ResponseEntity.ok(result);
        } catch (Exception e) {
            log.error("‚ùå Erro ao adicionar pontos para usu√°rio {}", userId, e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Concede badge espec√≠fico a um usu√°rio (Admin only)
     */
    @PostMapping("/user/{userId}/badge/{badgeCode}")
    @Operation(summary = "Conceder Badge", 
               description = "Concede um badge espec√≠fico a um usu√°rio")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> awardBadge(
            @PathVariable @Parameter(description = "ID do usu√°rio") Long userId,
            @PathVariable @Parameter(description = "C√≥digo do badge") String badgeCode) {
        
        log.info("üèÖ Concedendo badge {} para usu√°rio {}", badgeCode, userId);
        
        try {
            boolean success = gamificationService.awardBadge(userId, badgeCode);
            
            return ResponseEntity.ok(Map.of(
                "success", success,
                "message", success ? "Badge concedido com sucesso" : "Badge j√° foi concedido anteriormente",
                "badgeCode", badgeCode,
                "userId", userId
            ));
        } catch (Exception e) {
            log.error("‚ùå Erro ao conceder badge {} para usu√°rio {}", badgeCode, userId, e);
            return ResponseEntity.badRequest().body(Map.of(
                "success", false,
                "message", "Erro ao conceder badge: " + e.getMessage()
            ));
        }
    }

    /**
     * Concede conquista espec√≠fica a um usu√°rio (Admin only)
     */
    @PostMapping("/user/{userId}/achievement/{achievementCode}")
    @Operation(summary = "Conceder Conquista", 
               description = "Concede uma conquista espec√≠fica a um usu√°rio")
    @PreAuthorize("hasRole('ADMIN')")
    public ResponseEntity<Map<String, Object>> awardAchievement(
            @PathVariable @Parameter(description = "ID do usu√°rio") Long userId,
            @PathVariable @Parameter(description = "C√≥digo da conquista") String achievementCode) {
        
        log.info("üèÜ Concedendo conquista {} para usu√°rio {}", achievementCode, userId);
        
        try {
            boolean success = gamificationService.awardAchievement(userId, achievementCode);
            
            return ResponseEntity.ok(Map.of(
                "success", success,
                "message", success ? "Conquista concedida com sucesso" : "Conquista j√° foi concedida anteriormente",
                "achievementCode", achievementCode,
                "userId", userId
            ));
        } catch (Exception e) {
            log.error("‚ùå Erro ao conceder conquista {} para usu√°rio {}", achievementCode, userId, e);
            return ResponseEntity.badRequest().body(Map.of(
                "success", false,
                "message", "Erro ao conceder conquista: " + e.getMessage()
            ));
        }
    }

    /**
     * Processa evento de gamifica√ß√£o
     */
    @PostMapping("/event/{eventType}")
    @Operation(summary = "Processar Evento", 
               description = "Processa um evento de gamifica√ß√£o (cria√ß√£o de evento, participa√ß√£o, etc.)")
    public ResponseEntity<Map<String, String>> processGamificationEvent(
            @PathVariable @Parameter(description = "Tipo do evento") String eventType,
            @RequestBody @Parameter(description = "Dados do evento") Map<String, Object> eventData,
            Authentication auth) {
        
        log.info("üéÆ Processando evento de gamifica√ß√£o: {} para usu√°rio: {}", eventType, auth.getName());
        
        try {
            Long userId = getUserIdFromAuth(auth);
            gamificationService.processGamificationEvent(eventType, userId, eventData);
            
            return ResponseEntity.ok(Map.of(
                "status", "success",
                "message", "Evento processado com sucesso",
                "eventType", eventType
            ));
        } catch (Exception e) {
            log.error("‚ùå Erro ao processar evento de gamifica√ß√£o: {}", eventType, e);
            return ResponseEntity.internalServerError().body(Map.of(
                "status", "error",
                "message", "Erro ao processar evento: " + e.getMessage()
            ));
        }
    }

    /**
     * Obt√©m progresso de conquistas do usu√°rio atual
     */
    @GetMapping("/my-progress")
    @Operation(summary = "Meu Progresso", 
               description = "Retorna o progresso atual em conquistas e badges")
    public ResponseEntity<Map<String, Object>> getMyProgress(Authentication auth) {
        log.info("üìà Solicita√ß√£o de progresso para usu√°rio: {}", auth.getName());
        
        try {
            Long userId = getUserIdFromAuth(auth);
            GamificationStatsResponse stats = gamificationService.getUserGamificationStats(userId);
            
            Map<String, Object> progress = Map.of(
                "level", stats.getLevel(),
                "levelName", stats.getLevelName(),
                "currentPoints", stats.getTotalPoints(),
                "pointsToNextLevel", stats.getPointsToNextLevel(),
                "badges", stats.getBadges().size(),
                "achievements", stats.getAchievements().size(),
                "streak", stats.getStreak(),
                "rank", stats.getRank(),
                "weeklyPoints", stats.getWeeklyPoints(),
                "monthlyPoints", stats.getMonthlyPoints()
            );
            
            return ResponseEntity.ok(progress);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar progresso", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Obt√©m desafios/metas personalizadas do usu√°rio
     */
    @GetMapping("/challenges")
    @Operation(summary = "Desafios Personalizados", 
               description = "Retorna desafios e metas personalizadas baseadas no perfil do usu√°rio")
    public ResponseEntity<List<Map<String, Object>>> getPersonalizedChallenges(Authentication auth) {
        log.info("üéØ Solicita√ß√£o de desafios personalizados para usu√°rio: {}", auth.getName());
        
        try {
            Long userId = getUserIdFromAuth(auth);
            GamificationStatsResponse stats = gamificationService.getUserGamificationStats(userId);
            
            // Gerar desafios baseados no perfil do usu√°rio
            List<Map<String, Object>> challenges = List.of(
                Map.of(
                    "id", "weekly_events",
                    "title", "Organizador da Semana",
                    "description", "Crie 3 eventos nesta semana",
                    "type", "weekly",
                    "target", 3,
                    "current", 1,
                    "reward", 150,
                    "expires", "2024-12-31T23:59:59"
                ),
                Map.of(
                    "id", "social_butterfly",
                    "title", "Borboleta Social",
                    "description", "Participe de 5 eventos diferentes",
                    "type", "monthly",
                    "target", 5,
                    "current", 2,
                    "reward", 250,
                    "expires", "2024-12-31T23:59:59"
                ),
                Map.of(
                    "id", "friend_collector",
                    "title", "Colecionador de Amigos",
                    "description", "Adicione 10 novos amigos",
                    "type", "ongoing",
                    "target", 10,
                    "current", 4,
                    "reward", 200,
                    "expires", null
                )
            );
            
            return ResponseEntity.ok(challenges);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar desafios personalizados", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Obt√©m hist√≥rico de atividades de gamifica√ß√£o
     */
    @GetMapping("/activity-history")
    @Operation(summary = "Hist√≥rico de Atividades", 
               description = "Retorna hist√≥rico de atividades de gamifica√ß√£o do usu√°rio")
    public ResponseEntity<List<Map<String, Object>>> getActivityHistory(
            @RequestParam(defaultValue = "30") @Parameter(description = "N√∫mero de dias do hist√≥rico") 
            int days,
            Authentication auth) {
        
        log.info("üìú Solicita√ß√£o de hist√≥rico de atividades para usu√°rio: {} - {} dias", auth.getName(), days);
        
        try {
            Long userId = getUserIdFromAuth(auth);
            
            // Simular hist√≥rico de atividades
            List<Map<String, Object>> history = List.of(
                Map.of(
                    "date", "2024-12-15T14:30:00",
                    "type", "badge_earned",
                    "title", "Badge Conquistado",
                    "description", "Organizador - Por criar 5 eventos",
                    "points", 100,
                    "icon", "üèÖ"
                ),
                Map.of(
                    "date", "2024-12-14T19:45:00",
                    "type", "points_earned",
                    "title", "Pontos Ganhos",
                    "description", "Participa√ß√£o em evento: Churrasco de Ver√£o",
                    "points", 50,
                    "icon", "üéâ"
                ),
                Map.of(
                    "date", "2024-12-13T16:20:00",
                    "type", "level_up",
                    "title", "Subiu de N√≠vel!",
                    "description", "Parab√©ns! Voc√™ chegou ao n√≠vel 4 - Organizador",
                    "points", 0,
                    "icon", "‚¨ÜÔ∏è"
                ),
                Map.of(
                    "date", "2024-12-12T10:15:00",
                    "type", "achievement_unlocked",
                    "title", "Conquista Desbloqueada",
                    "description", "Social Butterfly - Por ter 20+ amigos",
                    "points", 200,
                    "icon", "üèÜ"
                )
            );
            
            return ResponseEntity.ok(history);
        } catch (Exception e) {
            log.error("‚ùå Erro ao buscar hist√≥rico de atividades", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    /**
     * Obt√©m estat√≠sticas comparativas com amigos
     */
    @GetMapping("/compare-with-friends")
    @Operation(summary = "Comparar com Amigos", 
               description = "Compara estat√≠sticas de gamifica√ß√£o com amigos")
    public ResponseEntity<Map<String, Object>> compareWithFriends(Authentication auth) {
        log.info("üë• Solicita√ß√£o de compara√ß√£o com amigos para usu√°rio: {}", auth.getName());
        
        try {
            Long userId = getUserIdFromAuth(auth);
            
            // Simular compara√ß√£o com amigos
            Map<String, Object> comparison = Map.of(
                "myStats", Map.of(
                    "points", 2450,
                    "level", 5,
                    "badges", 8,
                    "achievements", 12,
                    "rank", 23
                ),
                "friendsComparison", List.of(
                    Map.of(
                        "name", "Jo√£o Silva",
                        "points", 2890,
                        "level", 6,
                        "status", "ahead",
                        "difference", 440
                    ),
                    Map.of(
                        "name", "Maria Santos",
                        "points", 2100,
                        "level", 4,
                        "status", "behind",
                        "difference", 350
                    ),
                    Map.of(
                        "name", "Pedro Costa",
                        "points", 2680,
                        "level", 5,
                        "status", "ahead",
                        "difference", 230
                    )
                ),
                "insights", List.of(
                    "Voc√™ est√° no top 15% dos seus amigos!",
                    "Mais 440 pontos para alcan√ßar Jo√£o Silva",
                    "Voc√™ ganhou 125 pontos a mais que a m√©dia dos amigos esta semana"
                )
            );
            
            return ResponseEntity.ok(comparison);
        } catch (Exception e) {
            log.error("‚ùå Erro ao comparar com amigos", e);
            return ResponseEntity.internalServerError().build();
        }
    }

    // ==================== M√âTODOS AUXILIARES ====================

    private Long getUserIdFromAuth(Authentication auth) {
        // Implementar extra√ß√£o do ID do usu√°rio da autentica√ß√£o
        // Por enquanto, simular
        return 1L;
    }
} 